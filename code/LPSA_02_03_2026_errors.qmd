---
title: "Untitled"
format: html
---
### Setup

```{r setup}
library(tidyverse)
library(readr)
library(stringr)
library(soiltexture)
library(knitr)
library(kableExtra)
```

### Load Data

```{r}
#lpsa <- read_csv("../output_do_not_push/lpsa_fixed_02_03_2026.csv")
lpsa <- read_csv("../output_do_not_push/lpsa_all_results_02_04_2026.csv") %>%
  rename(ID = sample_id, clay = clay_pct, sand = sand_pct, date = date_sampled)
#add silt:
lpsa <- lpsa %>%
  mutate(silt = 100 - sand - clay) %>%
  #create base ID by removing letter:
  mutate(BASE_ID = str_remove(ID, "[A-Z]$"))

```

### Texture Classification

```{r}
selected_data <- lpsa %>% 
  select(CLAY = clay, SILT = silt, SAND = sand) %>%
  as.data.frame()

texture_classes <- TT.points.in.classes(
  tri.data = selected_data,
  class.sys = "USDA.TT"
)
TT.plot(
  tri.data = selected_data,
  class.sys = "USDA.TT",
  col = "black",
  pch = 19,
  cex = 0.5,
  main = "Texture Classes for All Soil Samples"
)

# Extract primary and boundary info
texture_info <- apply(texture_classes, 1, function(x) {
  max_val <- max(x)
  classes <- colnames(texture_classes)[which(x == max_val)]
  list(
    primary = classes[1],  # first class if tie
    is_boundary = length(classes) > 1,
    boundary_classes = if(length(classes) > 1) paste(classes, collapse = " / ") else NA_character_
  )
})

# Add results back to lpsa2
lpsa2 <- lpsa %>%
  mutate(
    primary_texture = sapply(texture_info, `[[`, "primary"),
    is_boundary = sapply(texture_info, `[[`, "is_boundary"),
    boundary_classes = sapply(texture_info, `[[`, "boundary_classes")
  )

# Map USDA texture names to simplified classes
lpsa2 <- lpsa2 %>%
  mutate(
    texture_class = case_when(
      primary_texture == "SaClLo" ~ "SCL",
      primary_texture == "Clo" ~ "CL",
      primary_texture == "SaLo" ~ "SL",
      primary_texture == "SaCl" ~ "SC",
      primary_texture == "Lo" ~ "L",
      primary_texture == "LoSa" ~ "LS",
      primary_texture == "S" ~ "S",
      primary_texture == "Cl" ~ "C",
      primary_texture == "Si" ~ "SI",
      primary_texture == "SiL" ~ "SIL",
      primary_texture == "SiCl" ~ "SIC",
      primary_texture == "SiClLo" ~ "SICL",
      primary_texture == "SiLo" ~ "SIL",
      primary_texture == "Sa" ~ "S",
      TRUE ~ as.character(primary_texture)
    )
  )


lpsa2 <- lpsa2 %>%
  dplyr::select(BASE_ID = BASE_ID,ID = ID, CLAY = clay, SAND = sand, SILT = silt, texture_class, is_boundary, boundary_classes, date) 

results_table <- lpsa2 %>%
  kable(caption = "Texture Classifications for All Soil Samples", format = "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  scroll_box(height = "400px")
results_table


```
### BASE_ID Texture Class Agreement

```{r}
# ============================================================
# BASE_ID agreement / disagreement on texture_class
# Rule:
#   OK     = at least one class has n >= 2 within BASE_ID
#   FAILED = no class has n >= 2 (all samples disagree)
# ============================================================
#remove samples where clay = 100:
lpsa2 <- lpsa2 %>%
  filter(!(CLAY > 85))


base_summary <- lpsa2 %>%
  filter(!is.na(BASE_ID), BASE_ID != "", !is.na(texture_class), texture_class != "") %>%
  group_by(BASE_ID) %>%
  summarise(
    n_samples = n(),
    # frequency table of classes as a compact string: "SL:2 | L:1"
    class_counts = paste(
      paste0(names(sort(table(texture_class), decreasing = TRUE)),
             ":", as.integer(sort(table(texture_class), decreasing = TRUE))),
      collapse = " | "
    ),
    max_class_n = max(as.integer(table(texture_class))),
    agreed_class = names(which.max(table(texture_class))),
    status = if_else(max_class_n >= 2, "OK", "FAILED"),
    .groups = "drop"
  ) %>%
  arrange(desc(n_samples), desc(max_class_n), BASE_ID)

# Lists you asked for
agreement_baseIDs <- base_summary %>% filter(status == "OK")
disagreement_baseIDs <- base_summary %>% filter(status == "FAILED")

# If you also want the underlying samples for each list:
agreement_samples <- lpsa2 %>% semi_join(agreement_baseIDs, by = "BASE_ID") %>% arrange(BASE_ID, ID)
disagreement_samples <- lpsa2 %>% semi_join(disagreement_baseIDs, by = "BASE_ID") %>% arrange(BASE_ID, ID)

# Quick counts
base_summary %>% count(status)

# View (pick whichever you want to print)
agreement_baseIDs
disagreement_baseIDs


```
### 5% Tolerance

```{r}
# ============================================================
# Rescue check for disagreement BASE_IDs using sand/clay tolerance
# ============================================================

tol <- 5  # tolerance in percentage points (0–100 scale)

disagree_ids <- disagreement_baseIDs %>% select(BASE_ID)

disagree_samples <- lpsa2 %>%
  semi_join(disagree_ids, by = "BASE_ID") %>%
  filter(!is.na(SAND), !is.na(CLAY)) %>%
  mutate(
    SAND = as.numeric(SAND),
    CLAY = as.numeric(CLAY)
  )

pairwise_df <- disagree_samples %>%
  group_by(BASE_ID) %>%
  group_modify(\(d, key) {
    if (nrow(d) < 2) return(tibble())  # no pairs possible

    idx <- combn(seq_len(nrow(d)), 2)

    tibble(
      ID_1 = d$ID[idx[1,]],
      ID_2 = d$ID[idx[2,]],
      sand_1 = d$SAND[idx[1,]],
      sand_2 = d$SAND[idx[2,]],
      clay_1 = d$CLAY[idx[1,]],
      clay_2 = d$CLAY[idx[2,]],
      sand_diff = abs(sand_1 - sand_2),
      clay_diff = abs(clay_1 - clay_2),
      pass_sand = sand_diff <= tol,
      pass_clay = clay_diff <= tol,
      pass_any  = pass_sand & pass_clay
    )
  }) %>%
  ungroup()

# Base-level verdict
base_rescue <- pairwise_df %>%
  group_by(BASE_ID) %>%
  summarise(
    n_samples = n_distinct(c(ID_1, ID_2)),
    n_pairs = n(),
    any_pair_pass = any(pass_any, na.rm = TRUE),
    status = if_else(any_pair_pass, "OK", "TRULY_FAILED"),
    best_i = which.min(pmin(sand_diff, clay_diff)),
    best_pair = paste0(ID_1[best_i], " vs ", ID_2[best_i]),
    best_min_diff = min(pmin(sand_diff, clay_diff), na.rm = TRUE),
    best_sand_diff = sand_diff[best_i],
    best_clay_diff = clay_diff[best_i],
    .groups = "drop"
  ) %>%
  select(-best_i) %>%
  arrange(status, best_min_diff, BASE_ID)

rescued_baseIDs <- base_rescue %>% filter(status == "OK")
truly_failed_baseIDs <- base_rescue %>% filter(status == "TRULY_FAILED")

rescued_samples <- disagree_samples %>%
  semi_join(rescued_baseIDs, by = "BASE_ID") %>%
  arrange(BASE_ID, ID)

truly_failed_samples <- disagree_samples %>%
  semi_join(truly_failed_baseIDs, by = "BASE_ID") %>%
  arrange(BASE_ID, ID) 

# Quick counts + peek
base_rescue %>% count(status)


#status = TRULY_FAILED
base_rescue %>%
  filter(status == "TRULY_FAILED")


```
### Final Error

```{r}
# ============================================================
# Choose best 2-sample combo per BASE_ID and average
# ============================================================
tol <- 5  # 5 percentage points (0–100 scale)

# ===============================
# Helper: USDA texture from averages
# ===============================
usda_texture_from_avg <- function(sand, silt, clay) {
  tri <- data.frame(CLAY = clay, SILT = silt, SAND = sand)
  m <- soiltexture::TT.points.in.classes(tri.data = tri, class.sys = "USDA.TT")
  cls <- colnames(m)[which(m[1, ] == max(m[1, ], na.rm = TRUE))]
  cls[1]
}

simplify_usda <- function(primary_texture) {
  dplyr::case_when(
    primary_texture == "SaClLo" ~ "SCL",
    primary_texture == "Clo" ~ "CL",
    primary_texture == "SaLo" ~ "SL",
    primary_texture == "SaCl" ~ "SC",
    primary_texture == "Lo" ~ "L",
    primary_texture == "LoSa" ~ "LS",
    primary_texture == "S" ~ "S",
    primary_texture == "Cl" ~ "C",
    primary_texture == "Si" ~ "SI",
    primary_texture == "SiL" ~ "SIL",
    primary_texture == "SiCl" ~ "SIC",
    primary_texture == "SiClLo" ~ "SICL",
    primary_texture == "SiLo" ~ "SIL",
    primary_texture == "Sa" ~ "S",
    TRUE ~ as.character(primary_texture)
  )
}

# ===============================
# Safety: numeric cleanup
# ===============================
dat <- lpsa2 %>%
  filter(!is.na(BASE_ID), BASE_ID != "",
         !is.na(texture_class), texture_class != "") %>%
  mutate(
    SAND = as.numeric(SAND),
    SILT = as.numeric(SILT),
    CLAY = as.numeric(CLAY)
  ) %>%
  filter(!is.na(SAND), !is.na(SILT), !is.na(CLAY))

# ===============================
# Pairwise table
# ===============================
pairwise_all <- dat %>%
  group_by(BASE_ID) %>%
  group_modify(\(d, key) {
    if (nrow(d) < 2) return(tibble())

    idx <- combn(seq_len(nrow(d)), 2)

    tibble(
      ID_1 = d$ID[idx[1,]],
      ID_2 = d$ID[idx[2,]],
      class_1 = d$texture_class[idx[1,]],
      class_2 = d$texture_class[idx[2,]],
      same_class = class_1 == class_2,

      sand_1 = d$SAND[idx[1,]],
      sand_2 = d$SAND[idx[2,]],
      silt_1 = d$SILT[idx[1,]],
      silt_2 = d$SILT[idx[2,]],
      clay_1 = d$CLAY[idx[1,]],
      clay_2 = d$CLAY[idx[2,]],

      sand_diff = abs(sand_1 - sand_2),
      silt_diff = abs(silt_1 - silt_2),
      clay_diff = abs(clay_1 - clay_2),

      pass_5pct = (sand_diff <= tol) & (clay_diff <= tol),
      total_error = sand_diff + silt_diff + clay_diff
    )
  }) %>%
  ungroup()

# ===============================
# Final chooser + averaged texture
# ===============================
avg_best2_by_base <- dat %>%
  group_by(BASE_ID) %>%
  group_modify(\(d, key) {

    if (nrow(d) < 2) {
      return(tibble(
        n_samples = nrow(d),
        pick_status = "ONLY_ONE_SAMPLE",
        picked_ID_1 = NA_character_,
        picked_ID_2 = NA_character_,
        picked_class = NA_character_,
        avg_SAND = NA_real_,
        avg_SILT = NA_real_,
        avg_CLAY = NA_real_,
        avg_primary_texture = NA_character_,
        avg_texture_class = NA_character_,
        best_total_error = NA_real_
      ))
    }

    pw <- pairwise_all %>% filter(BASE_ID == key$BASE_ID)

    class_tab <- table(d$texture_class)
    modal_class <- names(which.max(class_tab))
    modal_n <- as.integer(max(class_tab))
    all_same_class <- length(class_tab) == 1

    pick_best <- function(x) x %>% arrange(total_error) %>% dplyr::slice(1)

    if (all_same_class) {
      chosen <- pick_best(pw)
      pick_status <- "ALL_CLASS_AGREE"

    } else if (modal_n >= 2) {
      chosen <- pw %>%
        filter(same_class, class_1 == modal_class) %>%
        { if (nrow(.) == 0) pw %>% filter(same_class) else . } %>%
        pick_best()
      pick_status <- "CLASS_OK"

    } else {
      pw_pass <- pw %>% filter(pass_5pct)
      if (nrow(pw_pass) > 0) {
        chosen <- pick_best(pw_pass)
        pick_status <- "RESCUED_5PCT"
      } else {
        chosen <- pick_best(pw)
        pick_status <- "FAILED"
      }
    }

    id1 <- chosen$ID_1[[1]]
    id2 <- chosen$ID_2[[1]]

    r1 <- d %>% filter(ID == id1) %>% slice(1)
    r2 <- d %>% filter(ID == id2) %>% slice(1)

    avg_sand <- mean(c(r1$SAND, r2$SAND))
    avg_silt <- mean(c(r1$SILT, r2$SILT))
    avg_clay <- mean(c(r1$CLAY, r2$CLAY))

    avg_primary_texture <- usda_texture_from_avg(avg_sand, avg_silt, avg_clay)
    avg_texture_class <- simplify_usda(avg_primary_texture)

    tibble(
      n_samples = nrow(d),
      pick_status = pick_status,
      picked_ID_1 = id1,
      picked_ID_2 = id2,
      picked_class = if (pick_status %in% c("ALL_CLASS_AGREE","CLASS_OK")) modal_class else NA_character_,
      avg_SAND = avg_sand,
      avg_SILT = avg_silt,
      avg_CLAY = avg_clay,
      avg_primary_texture = avg_primary_texture,
      avg_texture_class = avg_texture_class,
      best_total_error = chosen$total_error[[1]],
      best_sand_diff = chosen$sand_diff[[1]],
      best_silt_diff = chosen$silt_diff[[1]],
      best_clay_diff = chosen$clay_diff[[1]]
    )
  }) %>%
  ungroup() %>%
  arrange(pick_status, desc(n_samples), BASE_ID)

# View summary counts
avg_best2_by_base %>% count(pick_status)

# # Optional save
# write_csv(avg_best2_by_base, "../output_do_not_push/lpsa_baseID_best2_avg_02_03_2026.csv")

reruns <- avg_best2_by_base %>%
  #FAILED or ONLY_ONE_SAMPLE

  filter(pick_status %in% c("FAILED", "ONLY_ONE_SAMPLE"))
reruns


highclay <- avg_best2_by_base %>%
  filter(avg_CLAY >= 50) %>% 
  #sort high to low clay
  arrange(desc(avg_CLAY))
highclay

```


```{r}
#export but just keep BASE_ID, avg_SAND, avg_SILT, avg_CLAY, pick_status (rename to LPSA_texture_status), and picked_class (renamed to lab_texture_class)

final_output <- avg_best2_by_base %>%
  select(
    BASE_ID,
    avg_SAND,
    avg_SILT,
    avg_CLAY,
    LPSA_texture_status = pick_status,
    lab_texture_class = avg_texture_class
  )
final_output_no_fails <- final_output #%>%
  # filter(LPSA_texture_status == "ALL_CLASS_AGREE" | LPSA_texture_status == "CLASS_OK" | LPSA_texture_status == "RESCUED_5PCT")
final_fails <- final_output %>%
  filter(LPSA_texture_status == "FAILED" | LPSA_texture_status == "ONLY_ONE_SAMPLE")

final_output_no_fails
write_csv(final_output_no_fails, "../output_do_not_push/lpsa_final_texture_results_02_04_2026.csv")
final_fails
```








